/*
 * FILE : wrapper.c
 * 
 * This file was partially automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1  (Beta 5)
 * 
 * Copyright (c) 1995-1997
 * The University of Utah and The Regents of the University of California
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */

/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/beazley/SWIG/SWIG1.1b3/swig_lib/perl5/RCS/perl5ptr.swg,v 1.1 1996/12/26 22:17:29 beazley Exp beazley $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: perl5ptr.swg,v $
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    tmp = SvIV((SV*)SvRV(sv));
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else {
    tmp = 0;
  }
#ifdef ALLOW_NULL
  if (((void *) tmp) == 0) {
    *(ptr) = (void *) tmp;
    return (char *) 0;
  }
#endif
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
	  
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }
      i = 0;
      sp = (SwigPtrType *) bsearch(_t,SwigPtrTable,SwigPtrN,sizeof(SwigPtrType),swigcmp);
      if (sp) {
	while ((sp >= SwigPtrTable) && (swigcmp(_t,sp) == 0)) sp--;
	sp++;
	name = sp->name;
	len = sp->len;
	while (swigcmp(_t,sp) == 0) {
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strncpy(temp_type,tp->name,255);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(a,b,c) _swig_create_magic(a,b,c)
static void _swig_create_magic(char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(a,b,c) _swig_create_magic(pPerl,a,b,c)
static void _swig_create_magic(CPerl *pPerl, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  SV *sv;
  sv = perl_get_sv(name,TRUE);
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_Math__Random

#define SWIG_name   "Math::Random::boot_Math__Random"
#define SWIG_varinit "Math::Random::var_Random_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
void boot_Math__Random _((CV* cv));
#else
SWIGEXPORT(void,boot_Math__Random)(CPerl *, CV *cv);
#endif
extern float genbet(float ,float );
extern float genchi(float );
extern float genexp(float );
extern float genf(float ,float );
extern float gengam(float ,float );
extern float gennch(float ,float );
extern float gennf(float ,float ,float );
extern float gennor(float ,float );
extern float genunf(float ,float );
extern long ignbin(long ,float );
extern long ignnbn(long ,float );
extern long ignpoi(float );
extern long ignuin(long ,long );
extern void setall(long ,long );
extern void getsd(long *,long *);
extern void phrtsd(char *,long *,long *);
extern long gvpriw(long );
extern int rspriw(long );
extern float gvprfw(long );
extern void svprfw(long ,float );
extern int rsprfw(long );
extern void pgnprm(long );
extern void pgnmul(long ,long );
extern int psetmn(long );
extern int pgenmn();
extern void salfph(char *);
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_Random_var::
class _wrap_Random_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_genbet) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: genbet(aa,bb);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )genbet(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_genchi) {

    float  _result;
    float  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: genchi(df);");
    _arg0 = (float ) SvNV(ST(0));
    _result = (float )genchi(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_genexp) {

    float  _result;
    float  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: genexp(av);");
    _arg0 = (float ) SvNV(ST(0));
    _result = (float )genexp(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_genf) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: genf(dfn,dfd);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )genf(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gengam) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: gengam(a,r);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )gengam(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gennch) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: gennch(df,xnonc);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )gennch(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gennf) {

    float  _result;
    float  _arg0;
    float  _arg1;
    float  _arg2;

    int argvi = 0;
    dXSARGS;
    if ((items < 3) || (items > 3)) 
        croak("Usage: gennf(dfn,dfd,xnonc);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _arg2 = (float ) SvNV(ST(2));
    _result = (float )gennf(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gennor) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: gennor(av,sd);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )gennor(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_genunf) {

    float  _result;
    float  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: genunf(low,high);");
    _arg0 = (float ) SvNV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (float )genunf(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ignbin) {

    long  _result;
    long  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ignbin(n,pp);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (long )ignbin(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_ignnbn) {

    long  _result;
    long  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ignnbn(n,p);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    _result = (long )ignnbn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_ignpoi) {

    long  _result;
    float  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ignpoi(mu);");
    _arg0 = (float ) SvNV(ST(0));
    _result = (long )ignpoi(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_ignuin) {

    long  _result;
    long  _arg0;
    long  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ignuin(low,high);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (long )SvIV(ST(1));
    _result = (long )ignuin(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_setall) {

    long  _arg0;
    long  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: setall(iseed1,iseed2);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (long )SvIV(ST(1));
    setall(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_getsd) {

    long * _arg0;
    long * _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: getsd(OutSeed,OutSeed);");
{
  /* makes interface ignore seed argument input values */
  static long junk;
  _arg0 = &junk;
}
{
  /* makes interface ignore seed argument input values */
  static long junk;
  _arg1 = &junk;
}
    getsd(_arg0,_arg1);
{
  /* gets seed output from arguments */
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi), *_arg0);
  argvi++;
}
{
  /* gets seed output from arguments */
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi), *_arg1);
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_phrtsd) {

    char * _arg0;
    long * _arg1;
    long * _arg2;

    int argvi = 0;
    dXSARGS;
    if ((items < 3) || (items > 3)) 
        croak("Usage: phrtsd(phrase,OutSeed,OutSeed);");
    _arg0 = (char *) SvPV(ST(0),na);
{
  /* makes interface ignore seed argument input values */
  static long junk;
  _arg1 = &junk;
}
{
  /* makes interface ignore seed argument input values */
  static long junk;
  _arg2 = &junk;
}
    phrtsd(_arg0,_arg1,_arg2);
{
  /* gets seed output from arguments */
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi), *_arg1);
  argvi++;
}
{
  /* gets seed output from arguments */
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi), *_arg2);
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_gvpriw) {

    long  _result;
    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: gvpriw(index);");
    _arg0 = (long )SvIV(ST(0));
    _result = (long )gvpriw(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_rspriw) {

    int  _result;
    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: rspriw(size);");
    _arg0 = (long )SvIV(ST(0));
    _result = (int )rspriw(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_gvprfw) {

    float  _result;
    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: gvprfw(index);");
    _arg0 = (long )SvIV(ST(0));
    _result = (float )gvprfw(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_svprfw) {

    long  _arg0;
    float  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: svprfw(index,value);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (float ) SvNV(ST(1));
    svprfw(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_rsprfw) {

    int  _result;
    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: rsprfw(size);");
    _arg0 = (long )SvIV(ST(0));
    _result = (int )rsprfw(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_pgnprm) {

    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: pgnprm(n);");
    _arg0 = (long )SvIV(ST(0));
    pgnprm(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_pgnmul) {

    long  _arg0;
    long  _arg1;

    int argvi = 0;
    dXSARGS;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pgnmul(n,ncat);");
    _arg0 = (long )SvIV(ST(0));
    _arg1 = (long )SvIV(ST(1));
    pgnmul(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_psetmn) {

    int  _result;
    long  _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: psetmn(p);");
    _arg0 = (long )SvIV(ST(0));
    _result = (int )psetmn(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_pgenmn) {

    int  _result;

    int argvi = 0;
    dXSARGS;
    if ((items < 0) || (items > 0)) 
        croak("Usage: pgenmn();");
    _result = (int )pgenmn();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_salfph) {

    char * _arg0;

    int argvi = 0;
    dXSARGS;
    if ((items < 1) || (items > 1)) 
        croak("Usage: salfph(phrase);");
    _arg0 = (char *) SvPV(ST(0),na);
    salfph(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_perl5_Random_var_init) {
    dXSARGS;
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_Math__Random) {
	 dXSARGS;
	 char *file = __FILE__;
	 newXS("Math::Random::var_Random_init", _wrap_perl5_Random_var_init, file);
	 newXS("Math::Random::genbet", _wrap_genbet, file);
	 newXS("Math::Random::genchi", _wrap_genchi, file);
	 newXS("Math::Random::genexp", _wrap_genexp, file);
	 newXS("Math::Random::genf", _wrap_genf, file);
	 newXS("Math::Random::gengam", _wrap_gengam, file);
	 newXS("Math::Random::gennch", _wrap_gennch, file);
	 newXS("Math::Random::gennf", _wrap_gennf, file);
	 newXS("Math::Random::gennor", _wrap_gennor, file);
	 newXS("Math::Random::genunf", _wrap_genunf, file);
	 newXS("Math::Random::ignbin", _wrap_ignbin, file);
	 newXS("Math::Random::ignnbn", _wrap_ignnbn, file);
	 newXS("Math::Random::ignpoi", _wrap_ignpoi, file);
	 newXS("Math::Random::ignuin", _wrap_ignuin, file);
	 newXS("Math::Random::setall", _wrap_setall, file);
	 newXS("Math::Random::getsd", _wrap_getsd, file);
	 newXS("Math::Random::phrtsd", _wrap_phrtsd, file);
	 newXS("Math::Random::gvpriw", _wrap_gvpriw, file);
	 newXS("Math::Random::rspriw", _wrap_rspriw, file);
	 newXS("Math::Random::gvprfw", _wrap_gvprfw, file);
	 newXS("Math::Random::svprfw", _wrap_svprfw, file);
	 newXS("Math::Random::rsprfw", _wrap_rsprfw, file);
	 newXS("Math::Random::pgnprm", _wrap_pgnprm, file);
	 newXS("Math::Random::pgnmul", _wrap_pgnmul, file);
	 newXS("Math::Random::psetmn", _wrap_psetmn, file);
	 newXS("Math::Random::pgenmn", _wrap_pgenmn, file);
	 newXS("Math::Random::salfph", _wrap_salfph, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
